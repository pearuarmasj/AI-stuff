"""
Parse AssaultCube .map file to extract memory offsets.

The .map file is generated by Visual Studio during compilation and contains
exact addresses for all symbols. This is 100% reliable for any build.

Usage:
    python -m assaultcube_agent.memory.map_parser
"""

import re
import os
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Dict


# Default path to map file
DEFAULT_MAP_PATH = Path(__file__).parent.parent.parent / "deps" / "AC" / "source" / "vcpp" / "Release" / "assaultcube.map"


@dataclass
class MapSymbols:
    """Symbols extracted from .map file."""
    # Static pointers (RVA from module base)
    player1_rva: int = 0
    players_rva: int = 0
    sfactor_rva: int = 0
    ssize_rva: int = 0
    world_rva: int = 0

    # Computed offsets (subtract 0x400000 base)
    @property
    def player1_offset(self) -> int:
        return self.player1_rva - 0x400000 if self.player1_rva else 0

    @property
    def players_offset(self) -> int:
        return self.players_rva - 0x400000 if self.players_rva else 0

    @property
    def sfactor_offset(self) -> int:
        return self.sfactor_rva - 0x400000 if self.sfactor_rva else 0

    @property
    def ssize_offset(self) -> int:
        return self.ssize_rva - 0x400000 if self.ssize_rva else 0

    @property
    def world_offset(self) -> int:
        return self.world_rva - 0x400000 if self.world_rva else 0


def parse_map_file(map_path: Path) -> Optional[MapSymbols]:
    """
    Parse the .map file and extract symbol addresses.

    Args:
        map_path: Path to assaultcube.map

    Returns:
        MapSymbols with extracted addresses, or None if failed
    """
    if not map_path.exists():
        print(f"[!] Map file not found: {map_path}")
        return None

    symbols = MapSymbols()

    # Symbol patterns we're looking for
    # Format: "0003:0001f8c0       ?player1@@3PAVplayerent@@A 0058a8c0"
    # The last hex value is the RVA+Base (actual address)
    patterns = {
        'player1': r'\?player1@@3PAVplayerent@@A\s+([0-9a-fA-F]+)',
        'players': r'\?players@@3U\?\$vector@PAVplayerent@@@@A\s+([0-9a-fA-F]+)',
        'sfactor': r'\?sfactor@@3HA\s+([0-9a-fA-F]+)',
        'ssize': r'\?ssize@@3HA\s+([0-9a-fA-F]+)',
        'world': r'\?world@@3PAUsqr@@A\s+([0-9a-fA-F]+)',
    }

    print(f"[*] Parsing map file: {map_path}")

    with open(map_path, 'r') as f:
        content = f.read()

    for name, pattern in patterns.items():
        match = re.search(pattern, content)
        if match:
            rva = int(match.group(1), 16)
            setattr(symbols, f'{name}_rva', rva)
            print(f"  [+] {name}: 0x{rva:08X} (offset: 0x{rva - 0x400000:X})")
        else:
            print(f"  [!] {name}: NOT FOUND")

    return symbols


def generate_offsets_from_map(symbols: MapSymbols) -> str:
    """Generate offsets.py content from map symbols."""

    # Struct offsets are constant (based on C++ struct layout)
    # These don't change between builds - only the static pointers change
    return f'''"""
Centralized memory offsets for AssaultCube (from .map file).

Generated by map_parser.py from the Visual Studio build .map file.
This ensures 100% correct offsets for this specific build.

Update by running: python -m assaultcube_agent.memory.map_parser
"""

# =============================================================================
# AC VERSION
# =============================================================================
AC_VERSION = "custom-build (from .map file)"


# =============================================================================
# STATIC POINTERS (from module base)
# These come directly from the .map file and are exact for this build.
# =============================================================================

# Player1 pointer - points to local player's playerent struct
PLAYER1_PTR_OFFSET = 0x{symbols.player1_offset:X}

# Players array - std::vector<playerent*> containing all players
PLAYERS_ARRAY_OFFSET = 0x{symbols.players_offset:X}
PLAYERS_COUNT_OFFSET = 0x{symbols.players_offset + 8:X}  # vector end ptr

# World/map geometry (for LOS checking)
SFACTOR_OFFSET = 0x{symbols.sfactor_offset:X}
SSIZE_OFFSET = 0x{symbols.ssize_offset:X}
WORLD_PTR_OFFSET = 0x{symbols.world_offset:X}


# =============================================================================
# PLAYERENT STRUCT OFFSETS (from player pointer)
# These are based on the C++ struct layout and are stable across builds.
# =============================================================================

# Inheritance: physent -> dynent -> playerent + playerstate

# Position (vec o from physent, after vtable)
POS_X = 0x04
POS_Y = 0x08
POS_Z = 0x0C

# Velocity (vec vel)
VEL_X = 0x10
VEL_Y = 0x14
VEL_Z = 0x18

# View angles
YAW = 0x34
PITCH = 0x38

# Health and armor (from playerstate embedded in playerent)
# playerstate starts at offset 0xEC in playerent (after dynent)
HEALTH = 0xEC
ARMOR = 0xF0

# Frags and deaths (playerent fields after playerstate)
FRAGS = 0x1DC
DEATHS = 0x1E4

# Team
TEAM = 0x30C

# Weapon selection
GUNSELECT = 0x0  # TODO: Find if needed

# Ammo arrays (each NUMGUNS=9 ints, from playerstate)
# playerstate layout: health(4), armour(4), primary(4), nextprimary(4),
#                     gunselect(4), akimbo(4 padded), ammo[9], mag[9], ...
AMMO_BASE = 0x104
MAG_BASE = 0x128

# Damage stats (pstatshots[9] at 0x170, pstatdamage[9] at 0x194)
# These are used for reward tracking
PSTAT_DAMAGE_BASE = 0x194


# =============================================================================
# WORLD GEOMETRY
# =============================================================================

# sqr struct size (from world.h)
SQR_SIZE = 16

# sqr types
SQR_SOLID = 0
SQR_CORNER = 1
SQR_FHF = 2      # floor heightfield
SQR_CHF = 3      # ceiling heightfield
SQR_SPACE = 4
SQR_SEMISOLID = 5


# =============================================================================
# KNOWN PLAYER PTR OFFSETS FOR DIFFERENT VERSIONS
# =============================================================================

KNOWN_PLAYER_PTRS = [
    0x{symbols.player1_offset:X},  # Current build (from .map)
    0x18AC00,  # AC 1.3.0.2 (official)
    0x17E0A8,  # AC 1.3.x alternative
    0x10F4F4,  # AC 1.2.0.2
]


# =============================================================================
# DICT FORMAT (for backwards compatibility)
# =============================================================================

OFFSETS = {{
    "pos_x": POS_X,
    "pos_y": POS_Y,
    "pos_z": POS_Z,
    "vel_x": VEL_X,
    "vel_y": VEL_Y,
    "vel_z": VEL_Z,
    "yaw": YAW,
    "pitch": PITCH,
    "health": HEALTH,
    "armor": ARMOR,
    "frags": FRAGS,
    "deaths": DEATHS,
    "team": TEAM,
    "gunselect": GUNSELECT,
    "ammo_base": AMMO_BASE,
    "mag_base": MAG_BASE,
}}


# =============================================================================
# CONVENIENCE FUNCTION
# =============================================================================

def print_all_offsets():
    """Print all offsets for verification."""
    print(f"AssaultCube Memory Offsets (version {{AC_VERSION}})")
    print("=" * 50)
    print("\\nStatic Pointers (from module base):")
    print(f"  PLAYER1_PTR_OFFSET  = 0x{{PLAYER1_PTR_OFFSET:X}}")
    print(f"  PLAYERS_ARRAY_OFFSET = 0x{{PLAYERS_ARRAY_OFFSET:X}}")
    print(f"  WORLD_PTR_OFFSET    = 0x{{WORLD_PTR_OFFSET:X}}")
    print(f"  SSIZE_OFFSET        = 0x{{SSIZE_OFFSET:X}}")
    print(f"  SFACTOR_OFFSET      = 0x{{SFACTOR_OFFSET:X}}")

    print("\\nPlayerent Offsets (from player pointer):")
    print(f"  Position:  X=0x{{POS_X:02X}}, Y=0x{{POS_Y:02X}}, Z=0x{{POS_Z:02X}}")
    print(f"  Velocity:  X=0x{{VEL_X:02X}}, Y=0x{{VEL_Y:02X}}, Z=0x{{VEL_Z:02X}}")
    print(f"  View:      YAW=0x{{YAW:02X}}, PITCH=0x{{PITCH:02X}}")
    print(f"  Stats:     HEALTH=0x{{HEALTH:02X}}, ARMOR=0x{{ARMOR:02X}}")
    print(f"  Scores:    FRAGS=0x{{FRAGS:03X}}, DEATHS=0x{{DEATHS:03X}}")
    print(f"  TEAM=0x{{TEAM:03X}}")
    print(f"  PSTAT_DAMAGE_BASE=0x{{PSTAT_DAMAGE_BASE:03X}}")


if __name__ == "__main__":
    print_all_offsets()
'''


def main():
    print("=" * 60)
    print("  ASSAULTCUBE MAP FILE OFFSET EXTRACTOR")
    print("=" * 60)

    # Find map file
    map_path = DEFAULT_MAP_PATH

    if not map_path.exists():
        print(f"\n[!] Map file not found at: {map_path}")
        print("[!] Make sure you've built AssaultCube in Release mode.")
        print("[!] The map file is generated at: deps/AC/source/vcpp/Release/assaultcube.map")
        return

    # Parse
    symbols = parse_map_file(map_path)
    if not symbols:
        return

    # Validate
    if not symbols.player1_rva:
        print("\n[!] Failed to find player1 symbol!")
        return

    print("\n" + "=" * 60)
    print("Extracted offsets:")
    print(f"  Player1:  0x{symbols.player1_offset:X}")
    print(f"  Players:  0x{symbols.players_offset:X}")
    print(f"  World:    0x{symbols.world_offset:X}")
    print(f"  SSize:    0x{symbols.ssize_offset:X}")
    print(f"  SFactor:  0x{symbols.sfactor_offset:X}")

    # Generate offsets.py content
    new_content = generate_offsets_from_map(symbols)

    print("\n" + "=" * 60)
    print("Preview of generated offsets.py:")
    print("-" * 40)
    for line in new_content.split('\n')[10:35]:
        print(line)
    print("...")
    print("-" * 40)

    # Ask to save
    save = input("\nSave to offsets.py? (y/n): ").strip().lower()
    if save == 'y':
        offsets_path = Path(__file__).parent / "offsets.py"
        with open(offsets_path, 'w') as f:
            f.write(new_content)
        print(f"[+] Saved to {offsets_path}")

        # Also verify by importing
        print("\n[*] Verifying...")
        try:
            # Force reimport
            import importlib
            from . import offsets
            importlib.reload(offsets)
            offsets.print_all_offsets()
        except Exception as e:
            print(f"[!] Verification failed: {e}")
    else:
        print("[*] Not saved.")

    print("\n[+] Done!")


if __name__ == "__main__":
    main()
